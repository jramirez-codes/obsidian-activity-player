"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadJson = exports.loadSchema = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const http_client_1 = require("./http-client");
const debug_1 = __importDefault(require("debug"));
const json_schema_migrate_1 = require("json-schema-migrate");
const compat_1 = require("./compat");
const debug = (0, debug_1.default)("eslint-plugin-json-schema-validator:utils-schema");
const TTL = 1000 * 60 * 60 * 24;
const RELOADING = new Set();
function loadSchema(schemaPath, context) {
    return loadJsonInternal(schemaPath, context, (schema) => {
        (0, json_schema_migrate_1.draft7)(schema);
        return schema;
    });
}
exports.loadSchema = loadSchema;
function loadJson(jsonPath, context) {
    return loadJsonInternal(jsonPath, context);
}
exports.loadJson = loadJson;
function loadJsonInternal(jsonPath, context, edit) {
    if (jsonPath.startsWith("http://") || jsonPath.startsWith("https://")) {
        return loadJsonFromURL(jsonPath, context, edit);
    }
    if (jsonPath.startsWith("vscode://")) {
        let url = `https://raw.githubusercontent.com/ota-meshi/extract-vscode-schemas/main/resources/vscode/${jsonPath.slice(9)}`;
        if (!url.endsWith(".json")) {
            url = `${url}.json`;
        }
        return loadJsonFromURL(url, context, (orig) => {
            const result = edit?.(orig) ?? orig;
            if (jsonPath === "vscode://schemas/settings/machine") {
                const target = result?.properties?.["workbench.externalUriOpeners"]?.additionalProperties?.anyOf;
                removeEmptyEnum(target);
            }
            else if (jsonPath === "vscode://schemas/launch") {
                const target = result?.properties?.compounds?.items?.properties
                    ?.configurations?.items?.oneOf;
                removeEmptyEnum(target);
            }
            return result;
        });
    }
    const json = fs_1.default.readFileSync(path_1.default.resolve((0, compat_1.getCwd)(context), jsonPath), "utf-8");
    const data = JSON.parse(json);
    return edit ? edit(data) : data;
}
function removeEmptyEnum(target) {
    if (!target)
        return;
    if (Array.isArray(target)) {
        for (const e of target) {
            removeEmptyEnum(e);
        }
        return;
    }
    if (Array.isArray(target.enum) && target.enum.length === 0) {
        delete target.enum;
        return;
    }
    if (target.type === "object" &&
        target.properties &&
        typeof target.properties === "object") {
        for (const key of Object.keys(target.properties)) {
            removeEmptyEnum(target.properties[key]);
        }
    }
}
function loadJsonFromURL(jsonPath, context, edit) {
    let jsonFileName = jsonPath.replace(/^https?:\/\//u, "");
    if (!jsonFileName.endsWith(".json")) {
        jsonFileName = `${jsonFileName}.json`;
    }
    const jsonFilePath = path_1.default.join(__dirname, `../../.cached_schemastore/${jsonFileName}`);
    const options = context.settings?.["json-schema-validator"]?.http;
    const httpRequestOptions = options?.requestOptions ?? {};
    const httpGetModulePath = resolvePath(options?.getModulePath, context);
    makeDirs(path_1.default.dirname(jsonFilePath));
    let data, timestamp;
    try {
        ({ data, timestamp } =
            require(`../../.cached_schemastore/${jsonFileName}`));
    }
    catch {
    }
    if (data != null && typeof timestamp === "number") {
        if (timestamp + TTL < Date.now()) {
            if (!RELOADING.has(jsonFilePath)) {
                RELOADING.add(jsonFilePath);
                (0, http_client_1.get)(jsonPath, httpRequestOptions, httpGetModulePath).then((json) => {
                    postProcess(jsonPath, jsonFilePath, json, context, edit);
                    RELOADING.delete(jsonFilePath);
                });
            }
        }
        return data;
    }
    let json;
    try {
        json = (0, http_client_1.syncGet)(jsonPath, httpRequestOptions, httpGetModulePath);
    }
    catch (e) {
        debug(e.message);
        return null;
    }
    return postProcess(jsonPath, jsonFilePath, json, context, edit);
}
function postProcess(schemaUrl, jsonFilePath, json, context, edit) {
    let data;
    try {
        data = JSON.parse(json);
    }
    catch {
        context.report({
            loc: { line: 1, column: 0 },
            message: `Could not be parsed JSON: "${schemaUrl}"`,
        });
        return null;
    }
    if (edit) {
        data = edit(data);
    }
    fs_1.default.writeFileSync(jsonFilePath, schemaStringify({
        data,
        timestamp: Date.now(),
        v: require("../../package.json").version,
    }));
    delete require.cache[jsonFilePath];
    return data;
}
function makeDirs(dir) {
    const dirs = [dir];
    while (!fs_1.default.existsSync(dirs[0])) {
        dirs.unshift(path_1.default.dirname(dirs[0]));
    }
    dirs.shift();
    for (const dir of dirs) {
        fs_1.default.mkdirSync(dir);
    }
}
function schemaStringify(schema) {
    return JSON.stringify(schema, (_key, value) => {
        return value;
    });
}
function resolvePath(modulePath, context) {
    if (!modulePath) {
        return undefined;
    }
    if (modulePath.startsWith(".")) {
        return path_1.default.join((0, compat_1.getCwd)(context), modulePath);
    }
    return modulePath;
}
