"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonc_eslint_parser_1 = require("jsonc-eslint-parser");
const yaml_eslint_parser_1 = require("yaml-eslint-parser");
const toml_eslint_parser_1 = require("toml-eslint-parser");
const utils_1 = require("../utils");
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const ast_1 = require("../utils/ast");
const schema_1 = require("../utils/schema");
const validator_factory_1 = require("../utils/validator-factory");
const fs_1 = __importDefault(require("fs"));
const compat_1 = require("../utils/compat");
const CATALOG_URL = "https://www.schemastore.org/api/json/catalog.json";
function matchFile(filename, fileMatch) {
    return (fileMatch.includes(path_1.default.basename(filename)) ||
        fileMatch.some((fm) => (0, minimatch_1.default)(filename, fm, { dot: true })));
}
function schemaPathToValidator(schemaPath, context) {
    const schema = (0, schema_1.loadSchema)(schemaPath, context);
    if (!schema) {
        return null;
    }
    return (0, validator_factory_1.compile)(schema, schemaPath, context);
}
function schemaObjectToValidator(schema, context) {
    if (!schema) {
        return null;
    }
    const schemaPath = (0, compat_1.getCwd)(context);
    return (0, validator_factory_1.compile)(schema, schemaPath, context);
}
function reportCannotResolvedPath(schemaPath, context) {
    context.report({
        loc: { line: 1, column: 0 },
        message: `Specified schema could not be resolved. Path: "${schemaPath}"`,
    });
}
function reportCannotResolvedObject(context) {
    context.report({
        loc: { line: 1, column: 0 },
        message: `Specified schema could not be resolved.`,
    });
}
const SCHEMA_KINDS = ["$schema", "options", "catalog"];
function parseMergeSchemasOption(option) {
    return option === true
        ? SCHEMA_KINDS
        : Array.isArray(option)
            ? [...option].sort((a, b) => SCHEMA_KINDS.indexOf(a) - SCHEMA_KINDS.indexOf(b))
            : null;
}
exports.default = (0, utils_1.createRule)("no-invalid", {
    meta: {
        docs: {
            description: "validate object with JSON Schema.",
            categories: ["recommended"],
            default: "warn",
        },
        fixable: undefined,
        schema: [
            {
                oneOf: [
                    { type: "string" },
                    {
                        type: "object",
                        properties: {
                            schemas: {
                                type: "array",
                                items: {
                                    type: "object",
                                    properties: {
                                        name: { type: "string" },
                                        description: { type: "string" },
                                        fileMatch: {
                                            type: "array",
                                            items: { type: "string" },
                                            minItems: 1,
                                        },
                                        schema: { type: ["object", "string"] },
                                    },
                                    additionalProperties: true,
                                    required: ["fileMatch", "schema"],
                                },
                            },
                            useSchemastoreCatalog: { type: "boolean" },
                            mergeSchemas: {
                                oneOf: [
                                    { type: "boolean" },
                                    {
                                        type: "array",
                                        items: {
                                            type: "string",
                                            enum: ["$schema", "catalog", "options"],
                                        },
                                        minItems: 2,
                                        uniqueItems: true,
                                    },
                                ],
                            },
                        },
                        additionalProperties: false,
                    },
                ],
            },
        ],
        messages: {},
        type: "suggestion",
    },
    create(context, { filename }) {
        const sourceCode = (0, compat_1.getSourceCode)(context);
        const cwd = (0, compat_1.getCwd)(context);
        const relativeFilename = filename.startsWith(cwd)
            ? path_1.default.relative(cwd, filename)
            : filename;
        const validator = createValidator(context, relativeFilename);
        if (!validator) {
            return {};
        }
        let existsExports = false;
        function validateData(data, resolveLoc) {
            const errors = validator(data);
            for (const error of errors) {
                const loc = resolveLoc(error);
                if (!loc) {
                    continue;
                }
                context.report({
                    loc,
                    message: error.message,
                });
            }
        }
        function validateJSExport(node, rootRange) {
            if (existsExports) {
                return;
            }
            existsExports = true;
            const data = (0, ast_1.analyzeJsAST)(node, rootRange, context);
            if (data == null) {
                return;
            }
            validateData(data.object, (error) => {
                let target = data.pathData;
                for (const p of error.path) {
                    const next = target?.children.get(p);
                    target = typeof next === "symbol" ? undefined : next;
                }
                const key = target?.key;
                const range = typeof key === "function" ? key(sourceCode) : key;
                if (!range) {
                    return null;
                }
                return {
                    start: sourceCode.getLocFromIndex(range[0]),
                    end: sourceCode.getLocFromIndex(range[1]),
                };
            });
        }
        function findSchemaPathFromJSON(node) {
            const rootExpr = node.body[0].expression;
            if (rootExpr.type !== "JSONObjectExpression") {
                return null;
            }
            for (const prop of rootExpr.properties) {
                if (prop.computed ||
                    (prop.key.type === "JSONIdentifier"
                        ? prop.key.name
                        : prop.key.value) !== "$schema") {
                    continue;
                }
                return (0, jsonc_eslint_parser_1.getStaticJSONValue)(prop.value);
            }
            return null;
        }
        return {
            Program(node) {
                if (sourceCode.parserServices.isJSON) {
                    const program = node;
                    validateData((0, jsonc_eslint_parser_1.getStaticJSONValue)(program), (error) => {
                        return errorDataToLoc((0, ast_1.getJSONNodeFromPath)(program, error.path));
                    });
                }
                else if (sourceCode.parserServices.isYAML) {
                    const program = node;
                    validateData((0, yaml_eslint_parser_1.getStaticYAMLValue)(program), (error) => {
                        return errorDataToLoc((0, ast_1.getYAMLNodeFromPath)(program, error.path));
                    });
                }
                else if (sourceCode.parserServices.isTOML) {
                    const program = node;
                    validateData((0, toml_eslint_parser_1.getStaticTOMLValue)(program), (error) => {
                        return errorDataToLoc((0, ast_1.getTOMLNodeFromPath)(program, error.path));
                    });
                }
            },
            ExportDefaultDeclaration(node) {
                if (node.declaration.type === "FunctionDeclaration" ||
                    node.declaration.type === "ClassDeclaration" ||
                    node.declaration.type === "VariableDeclaration") {
                    return;
                }
                const defaultToken = sourceCode.getTokenBefore(node.declaration);
                validateJSExport(node.declaration, [
                    node.range[0],
                    defaultToken.range[1],
                ]);
            },
            AssignmentExpression(node) {
                if ((node.left.type === "Identifier" && node.left.name === "exports") ||
                    (node.left.type === "MemberExpression" &&
                        node.left.object.type === "Identifier" &&
                        node.left.object.name === "module" &&
                        node.left.computed === false &&
                        node.left.property.type === "Identifier" &&
                        node.left.property.name === "exports")) {
                    validateJSExport(node.right, node.left.range);
                }
            },
        };
        function errorDataToLoc(errorData) {
            if (errorData.key) {
                const range = errorData.key(sourceCode);
                return {
                    start: sourceCode.getLocFromIndex(range[0]),
                    end: sourceCode.getLocFromIndex(range[1]),
                };
            }
            return errorData.value.loc;
        }
        function findSchemaPathFromYAML(node) {
            const rootExpr = node.body[0]?.content;
            if (!rootExpr || rootExpr.type !== "YAMLMapping") {
                return null;
            }
            for (const pair of rootExpr.pairs) {
                if (!pair.key ||
                    !pair.value ||
                    pair.key.type !== "YAMLScalar" ||
                    pair.key.value !== "$schema") {
                    continue;
                }
                return (0, yaml_eslint_parser_1.getStaticYAMLValue)(pair.value);
            }
            return null;
        }
        function findSchemaPathFromTOML(node) {
            const rootExpr = node.body[0];
            for (const body of rootExpr.body) {
                if (body.type !== "TOMLKeyValue" || body.key.keys.length !== 1) {
                    continue;
                }
                const keyNode = body.key.keys[0];
                const key = keyNode.type === "TOMLBare" ? keyNode.name : keyNode.value;
                if (key !== "$schema") {
                    continue;
                }
                return (0, toml_eslint_parser_1.getStaticTOMLValue)(body.value);
            }
            return null;
        }
        function findSchemaPath(node) {
            let $schema = null;
            if (sourceCode.parserServices.isJSON) {
                const program = node;
                $schema = findSchemaPathFromJSON(program);
            }
            else if (sourceCode.parserServices.isYAML) {
                const program = node;
                $schema = findSchemaPathFromYAML(program);
            }
            else if (sourceCode.parserServices.isTOML) {
                const program = node;
                $schema = findSchemaPathFromTOML(program);
            }
            return typeof $schema === "string"
                ? $schema.startsWith(".")
                    ? path_1.default.resolve(path_1.default.dirname(typeof context.getPhysicalFilename === "function"
                        ? context.getPhysicalFilename()
                        : getPhysicalFilename((0, compat_1.getFilename)(context))), $schema)
                    : $schema
                : null;
        }
        function get$SchemaValidators(context) {
            const $schemaPath = findSchemaPath(sourceCode.ast);
            if (!$schemaPath)
                return null;
            const validator = schemaPathToValidator($schemaPath, context);
            if (!validator) {
                reportCannotResolvedPath($schemaPath, context);
                return null;
            }
            return [validator];
        }
        function getCatalogValidators(context, relativeFilename) {
            const option = context.options[0] || {};
            const useSchemastoreCatalog = option.useSchemastoreCatalog !== false;
            if (!useSchemastoreCatalog) {
                return null;
            }
            const catalog = (0, schema_1.loadJson)(CATALOG_URL, context);
            if (!catalog) {
                return null;
            }
            const validators = [];
            for (const schemaData of catalog.schemas) {
                if (!schemaData.fileMatch) {
                    continue;
                }
                if (schemaData.fileMatch.some((s) => /^\*\.json$/u.test(s))) {
                    continue;
                }
                if (!matchFile(relativeFilename, schemaData.fileMatch)) {
                    continue;
                }
                const validator = schemaPathToValidator(schemaData.url, context);
                if (validator)
                    validators.push(validator);
            }
            return validators.length ? validators : null;
        }
        function getOptionsValidators(context, filename) {
            const option = context.options[0];
            if (typeof option === "string") {
                const validator = schemaPathToValidator(option, context);
                return validator ? [validator] : null;
            }
            if (typeof option !== "object" || !Array.isArray(option.schemas)) {
                return null;
            }
            const validators = [];
            for (const schemaData of option.schemas) {
                if (!matchFile(filename, schemaData.fileMatch)) {
                    continue;
                }
                if (typeof schemaData.schema === "string") {
                    const validator = schemaPathToValidator(schemaData.schema, context);
                    if (validator) {
                        validators.push(validator);
                    }
                    else {
                        reportCannotResolvedPath(schemaData.schema, context);
                    }
                }
                else {
                    const validator = schemaObjectToValidator(schemaData.schema, context);
                    if (validator) {
                        validators.push(validator);
                    }
                    else {
                        reportCannotResolvedObject(context);
                    }
                }
            }
            return validators.length ? validators : null;
        }
        function createValidator(context, filename) {
            const mergeSchemas = parseMergeSchemasOption(context.options[0]?.mergeSchemas);
            const validatorsCtx = createValidatorsContext(context, filename);
            if (mergeSchemas && mergeSchemas.some((kind) => validatorsCtx[kind])) {
                const validators = [];
                for (const kind of mergeSchemas) {
                    const v = validatorsCtx[kind];
                    if (v)
                        validators.push(...v);
                }
                return margeValidators(validators);
            }
            const validators = validatorsCtx.$schema || validatorsCtx.options || validatorsCtx.catalog;
            if (!validators) {
                return null;
            }
            return margeValidators(validators);
            function margeValidators(validators) {
                return (data) => validators.reduce((errors, validator) => [...errors, ...validator(data)], []);
            }
        }
        function createValidatorsContext(context, filename) {
            let $schema = null;
            let options = null;
            let catalog = null;
            function get(cache, setCache, supplier) {
                if (cache) {
                    return cache.validators;
                }
                const v = supplier();
                setCache({ validators: v });
                return v;
            }
            return {
                get $schema() {
                    return get($schema, (c) => ($schema = c), () => get$SchemaValidators(context));
                },
                get options() {
                    return get(options, (c) => (options = c), () => getOptionsValidators(context, filename));
                },
                get catalog() {
                    return get(catalog, (c) => (catalog = c), () => getCatalogValidators(context, filename));
                },
            };
        }
    },
});
function getPhysicalFilename(filename, child) {
    try {
        if (fs_1.default.statSync(filename).isDirectory()) {
            return child || filename;
        }
    }
    catch (err) {
        const { code } = err;
        if (code === "ENOTDIR" || code === "ENOENT") {
            return getPhysicalFilename(path_1.default.dirname(filename), filename);
        }
    }
    return filename;
}
